{docbook}
<abstract>
<para>This chapters represents issues related to creating a new content manually via the following topics:</para>
<itemizedlist>
  <listitem>
	<para>
	  <link linkend="DEV.WorkWithContent.NodeType">Node type</link>
	</para>
  </listitem>
  <listitem>
	<para>
	  <link linkend="DEV.WorkWithContent.WCMTemplate">WCM template</link>
	</para>
  </listitem>
  <listitem>
	<para>
	  <link linkend="DEV.WorkWithContent.DocumentType">Document type</link>
	</para>
  </listitem>
  <listitem>
	<para>
	  <link linkend="DEV.WorkWithContent.DialogSyntax">Dialog Syntax</link>
	</para>
  </listitem>
  <listitem>
	<para>
	  <link linkend="DEV.WorkWithContent.CKEditor">Customize CKEditor</link>
	</para>
  </listitem>
  <listitem>
	<para>
	  <link linkend="DEV.WorkWithContent.Taxonomy">Taxonomy</link>
	</para>
  </listitem>
  <listitem>
	<para>
	  <link linkend="DEV.WorkWithContent.ManageTemplateService">Manage Template service</link>
	</para>
  </listitem>
  <listitem>
	<para>
	  <link linkend="DEV.WorkWithContent.NavigationByContent">Manage Navigation By Content</link>
	</para>
  </listitem>
</itemizedlist>
</abstract>
{docbook}

{note}
eXo Platform provides you with 2 options to create the content for your new extension:
* Create new content manually.
* Import an existing content into your extension.
{note}

h1. Node type {anchor:id=DEV.WorkWithContent.NodeType}

To create a content for your extension, you first need to define a node type which represents the document type in the JCR. There are 2 ways to define your node type:

* Via the *Content Administration* portlet. For more details on how to create a note type via the *Content Administration* portlet, see the *[Manage node types|../../../user-guide/html/sect-User_Guide-Content_Types-Manage_Node_Types.html]* in the eXo Platform 3.5 user guide.
* Via the .xml configuration files by creating a _nodetypes-configuration.xml_ file in your extension as below.

{code:xml}
<nodeType name="exo:newnodetype" isMixin="true" hasOrderableChildNodes="false" primaryItemName=""> 
  <supertypes>
    <supertype>exo:article</supertype>
  </supertypes>
  <propertyDefinitions>
    <propertyDefinition name="text" requiredType="String" autoCreated="true" mandatory="true" onParentVersion="COPY"
    protected="false" multiple="false">
      <valueConstraints/>
    </propertyDefinition>
    <propertyDefinition name="date" requiredType="Date" autoCreated="false" mandatory="true" onParentVersion="COPY"
    protected="false" multiple="false">
      <valueConstraints/>
    </propertyDefinition>

  </propertyDefinitions>
</nodeType>
{code}

By defining a supertype, you can reuse other node types and extend them with more properties (just like inheritance in Object Oriented Programming).

h1. WCM template {anchor:id=DEV.WorkWithContent.WCMTemplate}

After defining your node type, you need to select templates which are applied to a node type or a metadata mixin type. eXo Platform provides 2 types of WCM templates, including:

* *dialogs* which are HTML forms for creating node instances.
* *views* which are HTML fragments for displaying nodes.

From the *Content Administration* portlet, the *Manage Template* module lists all existing node types that have been associated with *Dialog* and/or *View* templates.
These templates can be attached to permissions (in the usual _membership\:group_ form), so which specific templates are displayed according to user rights (which can be useful in a content validation workflow activity).

In eXo Platform, you can specify whether JavaScript is allowed to run on a field of the content template or not by using the _"option"_ parameter.

{docbook}
<para>
<citetitle>
<emphasis role="bold">
Enable JavaScrip
</emphasis>
</citetitle>
</para>
{docbook}

*1.* Go to *Content Administration --> Content Presentation --> Manage Templates*.

*2.* Edit your desired template.

*3.* Select the *Dialog* tab, and then edit the content of _Dialog1_ in the *View & Edit Template* form.

*4.* Add _option = noSanitization_ to the code in the *Main* field as the example below.

For example:
{code}
String [] htmlArguments = ["jcrPath = / node / default.html / JCR: content / JCR: data", "options = toolbar: CompleteWCM, height: '410px ', noSanitization" htmlContent];
{code}

By default, JavaScript is disabled for any fields of some content templates to prevent the XSS attacks.


h1. Document type {anchor:id=DEV.WorkWithContent.DocumentType}

The *Document Type* checkbox is to define if the node type should be a *Document Type* or not. If this checkbox is selected, the *Sites Explorer* considers such nodes as user content and applies the following behavior:

* The *View* template will be used to display the *DocumentType* nodes.

* The document types nodes can be created by the *Add Content* action. The forms shown in the *Add Document* action are the corresponding *Dialog* templates of each document type.

* Non-document types are hidden unless the *Show Non-document Nodes* option is checked.

Templates are written using Groovy Templates and will require experiences with JCR API and HTML notions.


h1. Dialog Syntax {anchor:id=DEV.WorkWithContent.DialogSyntax}

Dialogs are Groovy Templates that generate forms by mixing static HTML fragments and Groovy calls to the components responsible for building the UI at runtime. As a result, you will get a simple but powerful syntax.

h2. Interceptors {anchor:id=DEV.WorkWithContent.Interceptors}

By placing interceptors in your template, you will be able to execute a Groovy script just before and just after saving the node. Pre-save interceptors are mostly used to validate input values and their overall meaning while the post-save interceptor can be used to do some manipulations or references for the newly created node, such as binding it with a forum discussion or wiki space.

To place interceptors, use the following fragment:

{code:groovy}
<% uicomponent.addInterceptor("ecm-explorer/interceptor/PreNodeSaveInterceptor.groovy", "prev");%>
{code}

Interceptor Groovy scripts are managed in the 'Manage Script' section in the ECM admin portlet. They must implement the CmsScript interface. Pre-save interceptors obtain input values within the context:

{code:java}
public class PreNodeSaveInterceptor implements CmsScript {

  public PreNodeSaveInterceptor() {
  }

  public void execute(Object context) {
    Map inputValues = (Map) context;
    Set keys = inputValues.keySet();
    for(String key : keys) {
      JcrInputProperty prop = (JcrInputProperty) inputValues.get(key);
      println("   --> "+prop.getJcrPath());
    }
  }

  public void setParams(String[] params) {
  }

}
{code}

Whereas the post-save interceptor is passed the path of the saved node in the context:

{code:java}
<% uicomponent.addInterceptor("ecm-explorer/interceptor/PostNodeSaveInterceptor.groovy", "post");%>

public class PostNodeSaveInterceptor implements CmsScript {

  public PostNodeSaveInterceptor() {
  }

  public void execute(Object context) {
    String path = (String) context;

    println("Post node save interceptor, created node: "+path);
  }

  public void setParams(String[] params) {
  }
}
{code}


h2. Hidden fields {anchor:id=DEV.WorkWithContent.HiddenFields}

In the next code sample, each argument is composed of a set of keys and values. The order of arguments are not important and only the key matters. That example defines a field with the id as "hiddenField2", which will generate a hidden field. The value of this field will be automatically set to UTF-8 and no visible field will be printed on the form.

{code:groovy}
String[] hiddenField2 = ["jcrPath=/node/jcr:content/jcr:encoding", "visible=false", "UTF-8"];
uicomponent.addHiddenField("hiddenInput2", hiddenField2);
{code}

Once the form has been saved, the date value will be saved under the relative JCR path ./exo:image/jcr:lastModified.


h3. Non-value field {anchor:id=DEV.WorkWithContent.Non-ValueField}

You cannot either see the non-value field on the form or input value for them. Its value will be automatically created or defined when you are managing templates.

{code:groovy}
String[] hiddenField1 = ["jcrPath=/node/jcr:content", "nodetype=nt:resource", "mixintype=dc:elementSet", "visible=false"] ;
uicomponent.addHiddenField("hiddenInput1", hiddenField1) ;
{code}


h3. Non-editable fields {anchor:id=DEV.WorkWithContent.Non-EditableFields}

It is possible to create widgets that are non-editable (and then only used to print some information).

{code:java}
String[] fieldCategories = ["jcrPath=/node/exo:category", "multiValues=true", "reference=true", "editable=false"]; uicomponent.addTextField("categories", fieldCategories);
{code}


h3. Create node type or mixin type {anchor:id=DEV.WorkWithContent.CreateNodeTypeOrMixinType}

In many cases, when creating an instance where the node is out of form, you must still specify the CMS service about the node structure. Particularly, you must define if which node type is child of the newly created node or if the current node has any mixin type attributed.

By defining these arguments, the node and its children are created with the correct node type and mixin type.

See the following example:

{code:groovy}
String[] hiddenField = ["jcrPath=/node/jcrcontent", "nodetype=nt:resource", "mixintype=exo:rss-enable", "visible=false"] ;
uicomponent.addHiddenField("hiddenInput", hiddenField) ; 
{code}

h3. Hidden field with default value {anchor:id=DEV.WorkWithContent.HiddenFieldWithDefaultValue}

In the previous sample, the value was automatically created and set according to the current date. However, it is also possible to set a default value for a field.

{code:groovy}
String[] hiddenField = ["jcrPath=/node/jcrcontent/jcr:mimeType", "image/jpeg"] ;
uicomponent.addHiddenField("hiddenInput", hiddenField) ;
{code}

h3. Visible without null fields {anchor:id=DEV.WorkWithContent.VisibleWithoutNullFields}

It is possible to tell that a widget should be visible only if its value is not null or when the form is used to edit the node which has been existing.

{code:groovy}
String nameArgs[] = ["jcrPath=/node", "mixintype=mix:votable", "visible=if-not-null"];
uicomponent.addMixinField("name", nameArgs ) 
{code}

h3. WYSIWYG widget {anchor:id=DEV.WorkWithContent.WYSIWYGWidget}

Widgets are natively part of the eXo Platform product to provide a simple and easy way for users to get information and notification on their application. They complete the portlet application that focuses on more transactional behaviors. 

WYSIWYG stands for What You See Is What You Get. This widget is one of the most powerful tools. It renders an advanced JavaScript text editor with many functionalities, including the ability to dynamically upload images or flash assets into a JCR workspace and then to refer to them from the created HTML text.

{code:groovy}
String[] fieldSummary = ["jcrPath=/node/exo:summary", "options=basic"] ;
uicomponent.addWYSIWYGField("summary", fieldSummary) ;
{code}


{code:groovy}
String[] fieldContent = ["jcrPath=/node/exo:text", "options=toolbar:CompleteWCM,'height:410px'", ""] ;
uicomponent.addRichtextField("content", fieldContent)
{code}

The "options" argument is used to tell the component which toolbar should be used.

By default, there are five options for the toolbar: CompleteWCM, Default, BasicWCM, Basic, SuperBasicWCM.

* CompleteWCM: a full set of tools is shown.

The following buttons are shown: Source, Templates, Show Blocks, Cut, Copy, Paste Text, Undo, Redo, SpellCheck, WCM Insert Gadget, Flash, Table, 
Insert Special Character, WCM Insert Content Link, Bold, Italic, Underline, Strike Through, Justify Left, Justify Center, Justify Right, Justify Full,
Ordered List, Unordered List, Text Color, Background Color, Remove Format, Link, WCM Insert Portal Link, Unlink, Anchor, Style, Font Format, Font Name, Font Size, Maximize.

!images/CompleteWCMToolbar.png|align="center" width="120mm" fo:scalefit="1" html:scalefit="0"!

* Default: a large set of tools is shown, no "options" argument is needed in that case.

The following buttons are shown: Source, Templates, Cut, Copy, PasteText, Undo, Redo, SpellCheck, RemoveFormat, Bold, Italic, Underline, Strike Through, Ordered List, Unordered List, Link, Unlink, Anchor, Image, Flash, Table, Special Character, Text Color, Background Color, Show Blocks, Style, Font Format, Font Name, Font Size, Maximize.

!images/DefaultToolbar.png|align="center" width="120mm" fo:scalefit="1" html:scalefit="0"!

* BasicWCM: a minimal set of tools is shown. 

The following buttons are shown: Source, Bold, Italic, Underline, Strike Through, OrderedList, UnorderedList, Outdent, Indent, Justify Left, Justify Center, Justify Right, JustifyFull, Blockquote, Link, Unlink, WCM Insert Portal Link, WCM Insert Content Link, Show Blocks, Style, Font Format, Font Name, FontSize, Maximize.

!images/BasicWCMToolbar.png|align="center" width="120mm" fo:scalefit="1" html:scalefit="0"!

* Basic: 

The following buttons are shown: Source, Bold, Italic, Underline, Strike Through, Ordered List, Unordered List, Outdent, Indent, Justify Left, Justify Center, Justify Right, Justify Full, Blockquote, Link, Unlink, Show Blocks, Style, Font Format, Font Name, Font Size, Maximize.

!images/BasicTools.png|align="center" width="120mm" fo:scalefit="1" html:scalefit="0"!

* SuperBasicWCM: 

The following buttons are shown: Source, Bold, Italic, Underline, Justify Left, Justify Center, Justify Right, Justify Full, Link, Unlink, WCM Insert Portal Link, WCM Insert Gadget, WCM Insert Content Link.

!images/SuperBasicWCMToolbar.png|align="center" width="120mm" fo:scalefit="1" html:scalefit="0"!

There is also a simple text area widget, which has text-input area only: 

{code:groovy}
String [] descriptionArgs = ["jcrPath=/node/exo:title", "validate=empty"];
uicomponent.addTextAreaField("description", descriptionArgs) ;
{code}

h3. Create a custom RichText editor fields  {anchor:id=DEV.WorkWithContent.Create_a_custom_Richtext_editor_fields}

In the [WYSIWYG widget|#DEV.WorkWithContent.WYSIWYGWidget] section, you already know about a set of default toolbars (CompleteWCM, Default, BasicWCM, Basic, SuperBasicWCM). In this section, you will learn how to create a *RichText* editor with custom buttons.

Just edit the configuration file and modify or add new items to the configuration file of the *RichText* editor is located in: _apps/resource-static/src/main/Webapp/eXoConfig.js_

Take a look at the eXoConfig.js file to see a definition of a custom toolbar named "MyCustomToolbar":

{code:java}
FCKConfig.ToolbarSets["MyCustomToolbar"] = [
  ['Source','Templates','-','FitWindow','ShowBlocks'],
 ['Cut','Copy','PasteText','-','SpellCheck','-','Undo','Redo'],
 ['WCMInsertGadget','Flash','Table','SpecialChar', 'WCMInsertContent'],
 '/',
 ['Bold','Italic','Underline','StrikeThrough','-','JustifyLeft','JustifyCenter','JustifyRight','JustifyFull','-','OrderedList','UnorderedList','-','TextColor','BGColor','-','RemoveFormat'],
 ['Link','WCMInsertPortalLink','Unlink','Anchor'],
 '/',
 ['Style','FontFormat','FontName','FontSize']
] ;
{code}

Every toolbar set is composed of a series of "toolbar bands" that are grouped in the final toolbar layout. The bands items move together on new rows when resizing the editor.

Every toolbar band is defined as a separated JavaScript array of strings. Each string corresponds to an available toolbar item defined in the editor code or in a plugin.

* Put the desired button names in square bracket ("\[" & "\]") and separate them by commas to create a toolbar band. You can look at the above code to know all the possible toolbar item. If the toolbar item does not exist, a message will be displayed when loading the editor.

* Include a separator in the toolbar band by putting the "-" string on it.

* Separate each toolbar brands with commas.

* Use slash ("/") to tell the editor that you want to force the next bands to be rendered in a new row and not following the previous one.

{note}
The last toolbar band must have no comma after it.
{note}


h3. Simple select box widget {anchor:id=DEV.WorkWithContent.SimpleSelectBoxWidget}

The select box widget enables you to render a select box with static values. These values are enumerated in a comma-separated list in the "options" argument. The argument with no key (here "text/html") is selected by default.

{code:groovy}
String[] mimetype = ["jcrPath=/node/jcrcontent/jcr:mimeType", "text/html", "options=text/html,text/plain"] ;
uicomponent.addSelectBoxField("mimetype", mimetype) ;
{code}

As usual, the value will be stored at the relative path defined by the jcrPath directive argument.

For more examples on how to create WCM templates, refer to the [WCM Templates|../../../reference/html/CONTref.InsideWCMTemplates.html] section.

h3. Advanced dynamic select box {anchor:id=DEV.WorkWithContent.AdvancedDynamicSelectBox}

In many cases, the previous solution with static options is not good enough and one would like to have the select box checked dynamically. 
That is what eXo Platform provide thanks to the introduction of a Groovy script as shown in the code fragment below.

{code:groovy}
String[] args = ["jcrPath=/node/exodestWorkspace", "script=ecm-explorer/widget/FillSelectBoxWithWorkspaces:groovy", "scriptParams=production"];
uicomponent.addSelectBoxField("destWorkspace", args) ;
{code}

The script itself implements the CMS Script interface and the cast is done to get the select box object as shown in the script code which fills the select box with the existing JCR workspaces.

{code:java}
import java.util.List ;
import java.util.ArrayList ;

import org.exoplatform.services.jcr.RepositoryService;
import org.exoplatform.services.jcr.core.ManageableRepository;

import org.exoplatform.webui.form.UIFormSelectBox;
import org.exoplatform.webui.core.model.SelectItemOption;
import org.exoplatform.services.cms.scripts.CmsScript;

public class FillSelectBoxWithWorkspaces implements CmsScript {

  private RepositoryService repositoryService_;

  public FillSelectBoxWithWorkspaces(RepositoryService repositoryService) {
    repositoryService_ = repositoryService;
  }

  public void execute(Object context) {
    UIFormSelectBox selectBox = (UIFormSelectBox) context;

    ManageableRepository jcrRepository = repositoryService_.getRepository();
    List options = new ArrayList();
    String[] workspaceNames = jcrRepository.getWorkspaceNames();
    for(name in workspaceNames) {
      options.add(new SelectItem(name, name));
    }
    selectBox.setOptions(options);
  }

  public void setParams(String[] params) {
  }
}
{code}

{note}
It is also possible to provide a parameter to the script by using the argument "scriptParams".
{note}

h3. Widget with selector {anchor:id=DEV.WorkWithContent.WidgetWithSelector}


One of the most advanced functionalities of this syntax is the ability to plug your own component that shows an interface, enabling you to select the value of the field.

In the generated form, you will see an icon which is configurable thanks to the selectorIcon argument. The syntax is a bit more complex but not much.

{code:groovy}
String[] groupArgs = ["jcrPath=/node/exogroup", "selectorClass=org:exoplatform:ecm:webui:selector:UIGroupMemberSelector"];
uicomponent.addActionField("group", groupArgs);
{code}

You can plug your own component using the selectorClass argument. It must follow the eXo UIComponent mechanism and implements the interface ComponentSelector:

{code:java}
package org.exoplatform.ecm.webui.selector;

import org.exoplatform.webui.core.UIComponent;
public interface ComponentSelector {
  public UIComponent getSourceComponent() ;
  public void setSourceComponent(UIComponent uicomponent, String[] initParams) ;    
}

{code}


h3. Multi-valued widget {anchor:id=DEV.WorkWithContent.Multi-valueWidget}

A widget can have multiple values if you add the argument "multiValues=true" to the directive.

h1. Customize CKEditor  {anchor:id=DEV.WorkWithContent.CKEditor}

{include:document=CKEditor.wiki|syntax=confluence/1.0}

h1. Taxonomy {anchor:id=DEV.WorkWithContent.Taxonomy}

Taxonomy is a particular classification arranged in a hierarchical structure. Taxonomy trees in eXo Platform will help you organize your content into categories.

When you create a new taxonomy tree, you will add a pre-configured _exo\:action_ (_exo\:scriptAction_ or _exo\:businessProcessAction_) to the root node of the taxonomy tree. This action is triggered when a new document is added anywhere in the taxonomy tree. The default action moves the document to the physical storage location and replaces the document in the taxonomy tree with a symlink of the _exo\:taxonomyLink_ type pointing to it. The physical storage location is defined by a workspace name, a path and the current date and time.

Like adding document types, taxonomy trees can be managed through the *Content Administration* portlet, or by adding .xml configuration files.

To configure taxonomy trees by adding configuration files in the _/webapp/WEB-INF/conf/acme-portal/wcm/taxonomy/_ directory, create a new file called _$taxonomyName-taxonomies-configuration.xml_. For example, if the name of your taxonomy tree is "acme", the file should be named _acme-taxonomies-configuration.xml_.

You can view the file here: _$PLF-HOME\_/samples/acme-website/webapp/src/main/webapp/WEB-INF/conf/acme-portal/wcm/taxonomy/acme-taxonomies-configuration.xml_.

As you can see, the value-params enable you to define the repository, workspace, name of the tree and its JCR path. You can then configure 
permissions for each group of users in the portal, and the triggered action when a new document is added to the taxonomy tree. Finally, you can describe the structure and names of the categories inside your taxonomy tree.

h1. Manage Template service {anchor:id=DEV.WorkWithContent.ManageTemplateService}

The Template service enables you to create dialogs and view templates for each node type registered. Each node type may have many dialogs and view templates. The template will be used when creating or viewing nodes.

You can find the template service configuration in _/webapps/ecm-wcm-core/WEB-INF/conf/wcm-core/core-services-configuration.xml_.

{code:xml}
<component>
  <key>org.exoplatform.services.cms.templates.TemplateService</key>
  <type>org.exoplatform.services.cms.templates.impl.TemplateServiceImpl</type>
</component>
{code}

As usual, one can register a plugin inside the service. This plugin initializes default dialogs and views template of any node type as nt:file, exo:article, exo:workflowAction, exo:sendMailAction, and more.

{code:xml}
<component-plugins>
  <component-plugin>
    <name>addTemplates</name>
    <set-method>addTemplates</set-method>
    <type>org.exoplatform.services.cms.templates.impl.TemplatePlugin</type>
    .........
  </component-plugin>
</component-plugins>
{code}

With init-parameters as:

{code:xml}
<init-params>
  <value-param>
    <name>autoCreateInNewRepository</name>
    <value>true</value>
  </value-param>
  <value-param>
    <name>storedLocation</name>
    <value>war:/conf/ecm/artifacts/templates</value>
  </value-param>
  <value-param>
    <name>repository</name>
    <value>repository</value>
  </value-param>
  <object-param>
    <name>template.configuration</name>
    <description>configuration for the location of templates to inject in jcr</description>
    <object type="org.exoplatform.services.cms.templates.impl.TemplateConfig">
      <field name="nodeTypes">
        <collection type="java.util.ArrayList">
          <value>
            <object type="org.exoplatform.services.cms.templates.impl.TemplateConfig$NodeType">
              <field name="nodetypeName">
                <string>exo:article</string>
              </field>
              <field name="documentTemplate">
                <boolean>true</boolean>
              </field>
              <field name="label">
                <string>Article</string>
              </field>
              <field name="referencedView">
                <collection type="java.util.ArrayList">
                  <value>
                    <object type="org.exoplatform.services.cms.templates.impl.TemplateConfig$Template">
                      <field name="templateFile">
                        <string>/article/views/view1.gtmpl</string>
                      </field>
                      <field name="roles">
                        <string>*</string>
                      </field>
                    </object>
                  </value>
                </collection>
              </field>
              <field name="referencedDialog">
                <collection type="java.util.ArrayList">
                  <value>
                    <object type="org.exoplatform.services.cms.templates.impl.TemplateConfig$Template">
                      <field name="templateFile">
                        <string>/article/dialogs/dialog1.gtmpl</string>
                      </field>
                      <field name="roles">
                        <string>*</string>
                      </field>
                    </object>
                  </value>
                </collection>
              </field>
            </object>
          </value>
        </collection>
      </field>
    </object>
  </object-param>
</init-params>    
{code}

h1. Manage Navigation By Content {anchor:id=DEV.WorkWithContent.NavigationByContent}

*Navigation By Content* is a feature which allows users to browse content of each page easily. With this feature, users experiencing eXo Platform 3.5 can navigate from a page to another or browse site content inside one page directly from a contextual menu.

{include:document=navigation_by_content_feature.wiki|syntax=confluence/1.0}

h2. Create a new Content List template  {anchor:id=DEV.WorkWithContent.CreateNewContentListTemplate}

eXo Platform provide many powerful features to manipulate and expose any type of content on a page.
This is due to the fact that eXo stores the all the content in its Java Content Repository (JCR) and renders the content on a page using Groovy Templates.

In this how-to, you will learn to create and use template that are used in the *Content List* portlet. For example, in the ACME sample site you can show the content in 1 or 2 columns just by selecting different templates:

!images/1ColumnContent.png|width="120mm" align="center" fo:scalefit="1" html:scalefit="0"!

!images/2ColumnsContent.png|width="120mm" align="center" fo:scalefit="1" html:scalefit="0"!

{docbook}
<para>
<citetitle>
<emphasis role="bold">Create a new Content List Template</emphasis>
</citetitle>
</para>
{docbook}

In this section you will learn how to create a new template using eXo IDE. Before writing the new template, it is important to learn where the templates are stored.

*eXo Content Service: Template Storage*

Like many things inside eXo Platform, the eXo JCR is used to stored the templates. Templates are just a special type of content.
This allows developers to easily write and test code without having complex deployment process, but also it make the life easy to export a running configuration to another one.
For this you just need to use the standard JCR export/import features.

All the template and eXo Content Service configurations are stored inside a specific JCR workspace named: dms-system.

Each template type (Document Type, Content List, etc) is stored in a specific location. In this case, you are going to work on the *Content List* portlet so the template are stored inside the following folder:

{{/exo:ecm/views/templates/content-list-viewer/list/}}

Just for the fun of it, let's inspect this folder using the eXo CRaSH utility. If you are not interested you can jump to the [next section|#DEV.WorkWithContent.CreateNewContentListTemplateUsingIDE]. CRaSH is a shell for Java Content Repositories, the source of CRaSH is available on Google Code. So in the terminal window:

*1.* Connect to CRaSH using telnet client:

{docbook}
<para>
<command>
telnet 127.0.0.1 5000
</command>
</para>
{docbook}

*2.* Connect to the JCR workspace using the following command:

{docbook}
<para>
<command>
connect -u root -p gtn -c portal dms-system
</command>
</para>
{docbook}

Where: \-u is the user, \-p is the password, \-c is the Portal Container, and dms\-system is the workspace to use.

Connect to the JCR workspace using the following command:

{docbook}
<para>
<command>
connect -u root -p gtn -c portal dms-system
</command>
</para>
{docbook}

Where: \-u is the user, \-p is the password, \-c is the Portal Container, and dms\-system is the workspace to use.

*3.* Move the the folder that contains all the templates for the Content List portlet:

{docbook}
<para>
<command>
cd /exo:ecm/views/templates/content-list-viewer/list/
</command>
</para>
{docbook}

*4.* List all the templates using the "ls" command.

You can see the list of all the templates available for the *Content List* portlet.

*Create a new template using eXo IDE*  {anchor:id="DEV.WorkWithContent.CreateNewContentListTemplateUsingIDE"}

Let's create a new template using eXo IDE. For this, be sure that you are connected with a user that is a part of the /Developer group. The _root_ user can be used for the simplicity reason.

The first important step is to go the the template location by doing as follows:

*1.* Access the IDE: click !images/gear_icon.png|width=3mm fo:scalefit="1" html:scalefit="0"! *--> IDE*.

*2.* Switch to dms-system workspace:

In the IDE menu, click *My Spaces --> on Window --> Select Workspace*. And select the dms-system location in the dialog box and click *OK*.

*3.* In the file structure on the left navigate to the template location:

{{/exo:ecm/views/templates/content-list-viewer/list/}}

*4.* Create a new template:

In the IDE Menu click *File --> New --> Groovy Template*.

*5.* Save the file as "MyNewTemplate.gtmpl".

*6.* Enter some basic code:

{code}
<h1>This is my template</h1>
The date is <= new Date()>
{code}

*7.* Save the template.

*8.* Go back to the Home page of the Acme Site.

*9.* Switch to the Edit mode by clicking *Edit* on the *Administration* bar.

*10.* Move you mouse over the top of the list of news and click on the preference button !images/PreferencesIcon.png|width="3mm" fo:scalefit="1" html:scalefit="0"!.

*11.* In the list of templates, select "MyNewTemplate", and click *Save*.

!images/SelectTemplate.png|align="center" width="120mm" fo:scalefit="1" html:scalefit="0"!

You have created your new template, and use it on a page. Now, you should add some more interesting code to the template to really loop over the content based on the portlet configuration. But before this, it is important to talk about caching and code modification.

*eXo Template and Cache*

To improve performances and a running system, the compiled version of the template is cached by default. This is why when you are modifying a template, you do not see any change. There are two ways to work around this:

* Run eXo Platform in Debug mode, in this case, nothing is cached.
* Invalidate the cache manually using JMX.

Since working with no cache at all is not an option, here is the MBean you have to use to invalidate the Template Service cache:

* {{exo:portal="portal",service=cache,name="TemplateService"}}, then call the {{clearCache}} operation on it.

You can use any method to call your MBeans operation. In this guide, JConsole will be used:

!images/TemplateServiceCacheMbean.png|align="center" width="50mm" fo:scalefit="1" html:scalefit="0"!

Do not forget to call this operation each time you modify your template to be sure eXo recompiles the template.

*Accessing Content in the template*

The current code of the template is really simple. Now, you need to add code to print the content in the page. For this, you are going to use some eXo Content programming, once again in the IDE.

The template used by the *Content List* portlet is based on the following Java class {{org.exoplatform.wcm.webui.clv.UICLVPresentation}}, this class is responsible for setting the complete context that you can use in the template such as:

* The folder or category that contains the content to show. The *Folder Path* field in the preference screen.
* The display settings: title, number of documents, elements to show, etc.

Here is the code to access these preferences:

{code:java}
// import all the classes need in the template
import javax.jcr.Node;
import org.exoplatform.wcm.webui.paginator.UICustomizeablePaginator;
import org.exoplatform.wcm.webui.clv.UICLVPortlet;
import org.exoplatform.wcm.webui.Utils;
import org.exoplatform.services.wcm.core.NodeLocation;

// get the portlet preferences

def header = uicomponent.getHeader();
def isShowRssLink = uicomponent.isShowRssLink();
def isShowHeader = uicomponent.isShowField(UICLVPortlet.PREFERENCE_SHOW_HEADER);
def isShowRefresh = uicomponent.isShowField(UICLVPortlet.PREFERENCE_SHOW_REFRESH_BUTTON);

def isShowTitle = uicomponent.isShowField(UICLVPortlet.PREFERENCE_SHOW_TITLE);
def isShowDate = uicomponent.isShowField(UICLVPortlet.PREFERENCE_SHOW_DATE_CREATED);
def isShowLink = uicomponent.isShowField(UICLVPortlet.PREFERENCE_SHOW_LINK);
def isShowReadmore = uicomponent.isShowField(UICLVPortlet.PREFERENCE_SHOW_READMORE);
def isShowImage = uicomponent.isShowField(UICLVPortlet.PREFERENCE_SHOW_ILLUSTRATION) ;
def isShowSummary = uicomponent.isShowField(UICLVPortlet.PREFERENCE_SHOW_SUMMARY);
{code}

The {{uicomponent}} object is defined by the container class of the portlet that calls the template. This class contains many utility methods.
The code above retrieves all the preferences of the portlet, since the name is self-explanatory, it is not necessary to detail them, especially when you look at the preferences screen below:

!images/ContentListPreference.png|align="center" width="120mm" fo:scalefit="1" html:scalefit="0"!

Now, the template has all the preferences, it is time to loop on the content on printing the information.

The eXo Content Service provides API to manipulate the content, including pagination of content. The idea behind this is to let the Content Service manage the JCR query, sorting, caching and pagination of data.
So in your template, you will mainly manage two classes to loop through the content to show:

* {{uicomponent.getUIPageIterator()}} a paginator object that is configured based on the portlet preferences.
* {{uicomponent.getCurrentPageData()}} contains a list of the content (JCR Nodes) that should print on the current page.

So let's print all the content of the page as a simple HTML list:

{code:html}
<ul style="margin: 20px">
<%
      for (viewNode in uicomponent.getCurrentPageData()) {
        def title = viewNode.getProperty("exo:title").getString()
        print("<li>$title</li>");
      }
%>
</ul>
{code}

Just copy this code in your template, save it, refresh the cache and go to your page. You should see the list of the content in a simple HTML list.

On each content (Node), eXo Content API provides some helper method to easily manipulate the content and avoid using the JCR API directly. In the following code, you can see the most important methods accessing content properties:

{code:java}
def itemName = viewNode.getName();
def itemLink = uicomponent.getURL(viewNode);
def webdDavLink = uicomponent.getWebdavURL(viewNode);
def itemDateCreated = uicomponent.getCreatedDate(viewNode);
def itemModifiedDate = uicomponent.getModifiedDate(viewNode);
def itemAuthor = uicomponent.getAuthor(viewNode);
def imgSrc = uicomponent.getIllustrativeImage(viewNode);
def itemTitle = uicomponent.getTitle(viewNode);
def itemSummary = uicomponent.getSummary(viewNode);
{code}

One important point is the fact that these methods are responsible for many things, for example: formatting dates, returning complete URLs depending of the context of the portlet.

Based on these methods you can now work on the presentation of the information on the page. For example, the image and the title allows user to click to go in the detail view of the article. This is done simply by using the following code:

{code:java}
<%
  for (viewNode in uicomponent.getCurrentPageData()) {
    def itemName = viewNode.getName();
    def itemLink = uicomponent.getURL(viewNode);
    def webdDavLink = uicomponent.getWebdavURL(viewNode);
    def itemDateCreated = uicomponent.getCreatedDate(viewNode);
    def itemModifiedDate = uicomponent.getModifiedDate(viewNode);
    def itemAuthor = uicomponent.getAuthor(viewNode);
    def imgSrc = uicomponent.getIllustrativeImage(viewNode);
    def itemTitle = uicomponent.getTitle(viewNode);
    def itemSummary = uicomponent.getSummary(viewNode);

    %>
<div style="overflow: auto;">
  <img src="$imgSrc" align="left">
  <h3><a href="$itemLink">$itemTitle</a></h3>
  $itemSummary
</div>

<%
  }
%>
{code}

For simplicity reason, this code does not manage any null value. Also the template do not deal with the portlet preferences such as the "Header", "RSS" links and so on, do not hesitate to do it if you want. The Web site should look like the following image:

!images/NewSite.png|align="center" width="120mm" fo:scalefit="1" html:scalefit="0"!

The last important point is to add the support for the in context editing that allows the user to edit the content directly from the template. Once again, this is done with a method of the {{uicomponent}} object, that creates a DIV around the content. Let's add this to the template:

{code:java}
<%
  for (viewNode in uicomponent.getCurrentPageData()) {
    def itemName = viewNode.getName();
    def itemLink = uicomponent.getURL(viewNode);
    def webdDavLink = uicomponent.getWebdavURL(viewNode);
    def itemDateCreated = uicomponent.getCreatedDate(viewNode);
    def itemModifiedDate = uicomponent.getModifiedDate(viewNode);
    def itemAuthor = uicomponent.getAuthor(viewNode);
    def imgSrc = uicomponent.getIllustrativeImage(viewNode);
    def itemTitle = uicomponent.getTitle(viewNode);
    def itemSummary = uicomponent.getSummary(viewNode);

    %>
<div style="overflow: auto;">
  <%=uicomponent.addQuickEditDiv("MyTemplateContentEditor", viewNode)%>
  <img src="$imgSrc" align="left">
  <h3><a href="$itemLink">$itemTitle</a></h3>
  $itemSummary
  < /div>
</div>

<%
  }
%>
{code}

The lines 15 and 19 are new in this template and provide support for the *Quick Edit* feature.

You have finished creating a new template for eXo Platform Content Service using embedded IDE.

*Conclusion*

In this article you have learned how to create a new template for eXo Content Service, with some basic steps:

* Create a new Groovy Template using eXo IDE.
* Edit this template using the eXo Java Content API.
* Configure your *Content List* portlet instance on a page to select the new template.

Now, you can create your own templates and use your imagination to add cool features to your site.